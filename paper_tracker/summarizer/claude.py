"""Claude Code subprocess-based paper summarizer."""

import asyncio
import json
import subprocess
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

from paper_tracker.dateutil import get_current_datetime
from paper_tracker.fetcher.arxiv import Paper


@dataclass
class PaperSummary:
    """Summary of a paper generated by AI."""

    paper_id: str
    key_points: list[str]
    main_contributions: list[str]
    relevance_score: float
    summary_text: str
    generated_at: datetime

    def to_dict(self) -> dict[str, Any]:
        """Convert summary to dictionary.

        Returns:
            Dictionary representation of the summary
        """
        return {
            "paper_id": self.paper_id,
            "key_points": self.key_points,
            "main_contributions": self.main_contributions,
            "relevance_score": self.relevance_score,
            "summary_text": self.summary_text,
            "generated_at": self.generated_at.isoformat(),
        }


class Summarizer:
    """Summarize papers using Claude Code as a subprocess.

    Uses the gt-switcher pattern to invoke Claude Code in team agent mode.
    """

    def __init__(
        self,
        model: str = "claude-sonnet-4-6",
        gt_script_path: Path | None = None,
    ) -> None:
        """Initialize the summarizer.

        Args:
            model: Claude model to use for summarization
            gt_script_path: Path to gt.sh script. If None, uses default.
        """
        self.model = model
        self.gt_script_path = gt_script_path or Path.home() / "gt-switcher" / "gt.sh"

    async def summarize_paper(
        self,
        paper: Paper,
        keywords: list[str] | None = None,
    ) -> PaperSummary:
        """Generate a summary for a single paper.

        Args:
            paper: Paper to summarize
            keywords: Optional keywords to guide relevance scoring

        Returns:
            PaperSummary object with generated summary
        """
        prompt = self._build_prompt(paper, keywords)
        response = await self._call_claude(prompt)
        return self._parse_response(paper.id, response)

    async def summarize_papers(
        self,
        papers: list[Paper],
        keywords: list[str] | None = None,
    ) -> list[PaperSummary]:
        """Generate summaries for multiple papers.

        Args:
            papers: List of papers to summarize
            keywords: Optional keywords to guide relevance scoring

        Returns:
            List of PaperSummary objects
        """
        summaries: list[PaperSummary] = []

        for paper in papers:
            try:
                summary = await self.summarize_paper(paper, keywords)
                summaries.append(summary)
            except Exception as e:
                # Log error but continue with other papers
                print(f"Error summarizing paper {paper.id}: {e}")
                # Create a minimal summary for failed papers
                summaries.append(
                    PaperSummary(
                        paper_id=paper.id,
                        key_points=[],
                        main_contributions=[],
                        relevance_score=0.0,
                        summary_text=f"Error generating summary: {e}",
                        generated_at=get_current_datetime(),
                    )
                )

        return summaries

    def _build_prompt(self, paper: Paper, keywords: list[str] | None) -> str:
        """Build the prompt for Claude Code.

        Args:
            paper: Paper to summarize
            keywords: Optional keywords for relevance scoring

        Returns:
            Prompt string for Claude
        """
        keyword_text = ""
        if keywords:
            keyword_text = f"\nKeywords to consider for relevance: {', '.join(keywords)}"

        prompt = f"""You are an expert research assistant. Analyze the following arXiv paper and provide a structured summary.

Paper Title: {paper.title}
Authors: {', '.join(paper.authors)}
Abstract: {paper.abstract}
arXiv ID: {paper.id}
{keyword_text}

Please provide a JSON response with the following structure:
{{
    "key_points": [
        "Brief bullet point summarizing the main idea",
        "Another key point from the paper",
        "Third key point"
    ],
    "main_contributions": [
        "Description of the primary contribution",
        "Description of secondary contributions",
        "Any novel methods or techniques introduced"
    ],
    "relevance_score": 0.8,
    "summary_text": "A 2-3 sentence executive summary of the paper"
}}

Relevance score should be between 0.0 and 1.0 based on how relevant the paper is to the provided keywords (or general interest if no keywords provided).

Respond ONLY with valid JSON, no additional text."""

        return prompt

    async def _call_claude(self, prompt: str) -> str:
        """Call Claude Code as a subprocess.

        Uses gt-switcher pattern: source gt.sh && gt c && claude --agent team 5:executor

        Args:
            prompt: Prompt to send to Claude

        Returns:
            Claude's response text
        """
        # Build the command using gt-switcher (Claude native mode)
        cmd = [
            "bash",
            "-c",
            f"source {self.gt_script_path} && gt c && echo '{prompt}' | claude --agent team '5:executor'",
        ]

        try:
            # Run Claude Code as subprocess
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=str(Path.home()),
            )

            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                error_msg = stderr.decode() if stderr else "Unknown error"
                raise RuntimeError(f"Claude Code subprocess failed: {error_msg}")

            response = stdout.decode().strip()
            return response

        except Exception as e:
            raise RuntimeError(f"Failed to call Claude Code: {e}")

    def _parse_response(self, paper_id: str, response: str) -> PaperSummary:
        """Parse Claude's response into a PaperSummary.

        Args:
            paper_id: ID of the paper being summarized
            response: Raw response text from Claude

        Returns:
            PaperSummary object
        """
        try:
            # Try to extract JSON from the response
            # Claude might include markdown code blocks or other text
            json_start = response.find("{")
            json_end = response.rfind("}") + 1

            if json_start == -1 or json_end == 0:
                raise ValueError("No JSON found in response")

            json_str = response[json_start:json_end]
            data = json.loads(json_str)

            return PaperSummary(
                paper_id=paper_id,
                key_points=data.get("key_points", []),
                main_contributions=data.get("main_contributions", []),
                relevance_score=float(data.get("relevance_score", 0.0)),
                summary_text=data.get("summary_text", ""),
                generated_at=get_current_datetime(),
            )

        except (json.JSONDecodeError, ValueError) as e:
            # Fallback: create a summary from the raw text
            return PaperSummary(
                paper_id=paper_id,
                key_points=[],
                main_contributions=[],
                relevance_score=0.0,
                summary_text=response[:500],  # Truncate if too long
                generated_at=get_current_datetime(),
            )

    async def close(self) -> None:
        """Clean up resources.

        This is a no-op for the subprocess-based implementation,
        but included for interface compatibility.
        """
        pass
